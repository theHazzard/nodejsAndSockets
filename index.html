<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Curso NodeJs by theHazzard</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">   
      <header>
        <h1>Curso NodeJs</h1>
        <p>repositorio del curso empezado por @antoniopol</p>

        <p class="view"><a href="https://github.com/theHazzard/cursox">View the Project on GitHub <small>theHazzard/cursox</small></a></p>


        <ul>
          <li><a href="https://github.com/theHazzard/cursox/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/theHazzard/cursox/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/theHazzard/cursox">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
      <nav>
        <ul>
          <li><a href="#whatIsNode">Intro!</a></li>
          <li><a href="#SocketIo">Socket.IO</a></li>
          <li></li>
          <li></li>
          <li></li>
        </ul>
      </nav>
        <h3 id="whatIsNode">Node.js</h3>

        <p>
          Node.js te permite correr javascript del lado del servidor, es decir, utilizando el motor V8 de google permite correr javascript fuera del navegador, que es como comunmente era utilizado, node.js es un conjunto de librerias y funciones que corren sobre este motor de google
        </p>
        <h3 id="CallBack">Callback functions</h3>
        <p>
          lo que mas me a costado entender, es el manejo que tiene javascript de las funciones, javascript es un lenguaje funcional, y maneja las funciones como uno de sus objetos mas importantes, las funciones de callback, son enviadas como parametros a otras funciones, para ser llamadas desde dentro de las mismas
        </p>
        <p>
          voy a dar un ejemplo simple de callback para que se entienda bien su funcionamiento:
        </p>

        <pre>
          <code>
var suma = function(a,b,callback){
  var resutlado = a + b;
  callback(resultado);
};

suma(5,4,function(res){
  console.log(res);
});
          </code>
        </pre>
        <p>
          En el codigo anterior podemos ver que declaramos la funcion suma, la cual recibe 3 parametros, los 2 valores, y callback.
          Mas abajo vemos que llamamos a esta funcion para que realize la suma, y le pasamos una funcion declarada en la misma lista de parametros, la cual recibe un valor en "res" y lo imprime en consola.
          Entonces, que sucede? bien, dentro de suma realizamos la suma y le pasamos el resultado a callback, que es la funcion que le pasamos como parametro, la cual es llamada y imprime lindo y bonito el resultado.       
        </p>
        
        <h3>NPM</h3>
        <p>Node consta con un instalador de paquetes, el cual te permite installarlos de manera local en tu proyecto:</p>
        <pre><code>
npm install express
        </code></pre>
        <p>o de manera global:</p>
        <pre><code>
npm install -g express
        </code></pre>
        <p>de que me sirve una o la otra? bueno, algunos paquetes como el del ejemplo traen funciones que pueden ser llamadas al instalarlos de manera global, en el ejemplo, express puede ser llamado para crear una estructura basica de tu sitio, de esta manera</p>
        <pre><code>
express MiSitio -s -c stylus
        </code></pre>
        <p>en este ejemplo estamos creando un proyecto llamado MiSitio, este comando recibe parametros tambien, -s le dice que configure express para utilizar sesiones, y -c le dice que vamos a utilizar el motor stylus para el codigo css</p>
        <p>esto nos genera la configuracion basica para tener corriendo un proyecto en express, como el package.json, algunas vistas y tambien rutas</p>
        
        <h3 id="SocketIo">Socket.io</h3>
        <h4>Que es socket.io?</h4>
        <p>Socket.io es una libreria que apunta a crear aplicaciones realtime sin tener que preocuparte por el mecanismo de transporte de datos, o de el dispositivo final donde se corra tu aplicacion</p>
        <h4>Todo muy lindo pero... mecanismos de transporte?</h4>
        <p>El mecanismo de transporte es el metodo por el que se envian los datos, si tenes el ultimo chrome seguro tendras habilitado websockets, pero y si tu servidor no soporta websockets?, o en el caso que tengas un internet explorer 6, y un servidor que si soporte websockets, no podras utilizarlo?</p>
        <p>Aqui es donde entra socket.io, el verifica todo esto por su cuenta y decide cual es el mejor modo de transporte habilitado, si tenes un navegador que soporte websockets, usara websocket, sino, utilizara pooling, y dadas las circunstancias de que no este ninguno habilitado, insertara en tu pagina un swf (si, flash) y utilizara las funciones de flash para que todos puedan utilizar tu aplicacion!</p>
        <h4>Y esto en que me afecta a mi?</h4>
        <p>Pues facil, esto significa que tu aplicacion funcionara en cualquier dispositivo, con cualquier conexion y en cualquier circunstancia!</p>
        <h4>HeartBeats, timeouts etc.</h4>
        <p>una coneccion que no a recibido datos se cierra luego de haber pasado un tiempo, esto se conoce como timeout, entonces, que sucede si no e recibido datos en un buen tiempo a traves de un socket? facil! socket.io manda un heartbeat (literalmente significa latido de corazon) antes que termine el tiempo de timeout para informarle al servidor que seguimos vivos, gracias a esto la conexion sigue siempre activa, <b>esto lo hace solito socket.io</b> pero es bueno saberlo =)</p>
        
        <h3>Agregando sockets a nuestra aplicacion!</h3>
        <p>por fin la parte divertida! continuando la version que nos dejo nuestro amigo @antonioPol <a href="https://github.com/theHazzard/nodejsAndSockets/tree/v1.0" class="user-mention">v1.0</a> primero hay que instalar la libreria de sockets en nuestro proyecto, esto se puede realizar con el siguiente comando.</p>
        <pre><code>
npm install socket.io
        </code></pre>
        <p>ahora bien, una buena practica aqui, sobre todo si luego pensamos hacer un deployment a heroku o a nodejitsu es agregar el paquete al archivo packages.json, pero como yo soy perezoso, hay un comando para mi!</p>
        <pre><code>
npm install socket.io --save          
        </code></pre>
        <p>esto hace que se instale nuestro paquete o libreria, y ademas se agregue automaticamente al archivo packages.json, quedando de esta manera.</p>
        <pre><code>
"dependencies": {
  "express": "3.0.6",
  "jade": "0.28.1",
  "socket.io": "~0.9.13"
}          
        </code></pre>
        <p>ahora bien, desde aqui podemos continuar! para ello necesitamos, en el archivo app.js, agregar la libreria.</p>
        <pre><code>
var express = require('express')
  , routes = require('./routes')
  , user = require('./routes/user')
  , http = require('http')
  , path = require('path');          
        </code></pre>
        <p>ahora quedaria asi</p>
        <pre><code>
var express = require('express')
  , routes = require('./routes')
  , user = require('./routes/user')
  , app = express()
  , http = require('http').createServer(app)
  , io = require('socket.io')
  , io = io.listen(http)
  , path = require('path');
        </code></pre>
        <p>como podran ver se agrego la linea
        <br>
        <code>app = express()</code>
        <br>
        <p>esto estaba ya hecho mas abajo, pero es necesario hacerlo antes de declarar nuestra variable http, ya que ahora es necesario alimentar esta variable con nuestra instancia de express <br>ahora en la linea de abajo le agregamos el metodo createServer y le pasamos nuestra instancia de express. (en app)</p>
        <br>
        <p>ahora tenemos, debajo de <code>http</code> la variable <code>io</code></p>
        <code>io = require('socket.io')</code>
        <p>que hace esto? trae las funciones de la libreria a la variable <code>io!</code>, pues bien, ya tenemos en nuestra app las funciones de sockets.
        <br>pero esto no es todo!.
        <br>ahora hay que decirle a nuestra libreria que escuche por nuestro servidor http, como lo estamos haciendo en la linea de abajo</p>
        <code>io = io.listen(http)</code>
        <p>y listo, ahora en io, tenemos a nuestro socket escuchando en http</p>
        <p>solo nos queda decir que en el final, donde antes estaba escuchando nuestra instancia de http, hay que modificarlo de la siguiente manera</p>
        <pre><code>
http.listen(app.get('port'), function(){
  console.log("Express server listening on port " + app.get('port'));
});
        </code></pre>
        <p>esto se debe a que arriba ya estamos haciendo la parte de <code>.createServer</code><br><a href="https://github.com/theHazzard/nodejsAndSockets/tree/7ed0e0dff943890914de6c1369ea5e3d9000ea4d">Commit con los cambios explicados</a></p>
        
        <h3>Reciviendo los sockets conectados</h3>
        <h4 id='socketServer'>En el server...</h4>
        <pre><code>
io.sockets.on('connection',function (socket){
  socket.emit('mensaje','bienvenidos!')
})          
        </code></pre>
        <p>que estamos haciendo con esto? bueno, <code>io</code> es nuestra instancia de socket.io a la escucha de conexiones, ahora estamos agregando a los sockets un manejador del evento connection, osea, que cuando haya una conexion, ejecute la funcion que le estamos pasando, recuerdan lo de las <a href="#CallBack">funciones callback?</a>, bueno, aqui estamos haciendo uso de ellas, con esto le estamos diciendo "on connection do this", o "al haber una conexion hace esto" donde "esto" es la <b>funcion</b></p>
        <p>la funcion callback que le estamos pasando recibe como parametro el socket que se conecto, este a diferencia de io.sockets(que son todos los sockets) es una conexion individual, osea un usuario unico, o una conexion unica a dicho usuario.</p>
        <p>luego donde hacemos <code>socket.emit('evento','mensaje')</code> le estamos diciendo que a este socket unico e individual le mandemos el evento mensaje, con el mensaje bienvenidos!</p>
        <h4>Del lado del cliente...</h4>
        <p>Para que podamos recivir estos datos, en el lado del cliente hay que configurar la conexion, para ello voy a crear un archivo js con las conexiones y en si, todo mi javascript, el mismo quedaria mas o menos asi</p>
        <pre>
          <code>
$(document).on('ready',function(){
  var socket = io.connect('http://localhost:3000');
  socket.on('mensaje',function (mensaje){
    alert(mensaje);
  })
});</code>
        </pre>
        <p>como podemos apreciar, tambien hago uso de jquery (por el simbolito <code>$</code>)
        <br>
        creo la variable socket, donde creo la coneccion al servidor on la variable io (ahora les voy a mostrar donde esta declarada)
        <br>
        ahora abajo le digo, <code>socket.on('mensaje',function...);</code> esto significa, que cuando el socket reciba el evento <code>'mensaje'</code>, ejecute la funcion callback que le pasamos como parametro, que lo que hace es recibir el mensaje enviado por el servidor en la variable mensaje que recibe como parametro (recuerdan el <a href="#socketServer">Paso anterior?</a> donde le deciamos que envie el mensaje bienvenidos?, bueno, esta es la funcion que lo recibe, y lo muestra en un alert!</p>
        <b><p>El archivo lo nombre <code>skt.js</code> y lo guarde en <code>public</code></p></b>
        <h4>Configurando el html mostrado al usuario...</h4>
        <p>ahora, como proveo al usuario con este js?, en el archivo <code>layout.jade</code> el cual es quien henera el <code>head</code> de las paginas mostradas incluimos esto</p>
        <pre>
          <code>
script(src='skt.js')            
          </code>
        </pre>
        <p>no hace falta agregarle mas nada el path del <code>src</code> por que ya configuramos en express cual va a ser nuestro directorio publico, asi que todo lo que no este en las rutas lo va a buscar ahi
        <br>
        pero nos estan faltando otras cosas!, yo dije clarito que estoy usando Jquery en el selector, asi que arriba de la linea agregada tenemos que agregar jquery, lo vamos a hacer desde google, asi no alojamos en nuestra pagina el js =P
        </p>
        <pre>
          <code>
script(src='//ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js')            
          </code>
        </pre>
        <p>
          tambien, como estamos haciendo uso de <code>io.connect()</code> en algun lado debemos traer la libreria de socket.io para el cliente, lo hacemos con esta linea, que debemos agregar antes de nuestro archivo <code>js</code> que creamos.
        </p>
        <pre>
          <code>
script(src='/socket.io/socket.io.js')            
          </code>
        </pre>
        <p>ahora, de donde esta sacando este js? si en nuestra carpeta public no esta, ni tampoco tenemos una carpeta socket.io?, bueno, esta parte la interpreta socket.io, y le pasa el js automaticamente! asi que con esto ya estamos con el <a href="https://github.com/theHazzard/nodejsAndSockets/blob/d98b3fb4943063a914995d0ab7e564aec67f4c32/views/layout.jade">layout.jade</a></p>
        <h4>Autentificando los sockets</h4>
        <p>Para asegurarnos que solo nuestros usuarios se van a conectar como sockets, vamos a autentificar las conexiones, para ello debemos configurar socket.io</p>
        <p>Esto lo hacemos agregando debajo de nuestras variables la siguientes lineas</p>
        <pre><code>
io.configure(function (){
  io.set('authorization', function (handshakeData, callback) {})
});          
        </code></pre>
        <p>Ahi le estamos diciendo que se ejecute la funcion que le estoy pasando cuando se haga la autorizacion del socket, por defecto autoriza todas, pero ahora debera pasar por mi funcion antes de autorizar.</p>
        <p>Para ello, voy a ver dentro de las sesiones si la conexion que esta entrando esta logeada, osea, deberia tener creada session.user
        <br>
        las sesiones por defecto en node.js se guardan en una MemoryStore, osea, en memoria, para poder entrar a esta MemoryStore, debemos crearla donde declaramos nuestras variables, de la siguiente manera</p>
        <pre><code>
var MemoryStore = express.session.MemoryStore;          
        </code></pre>
        <p>ahora tenemos la clase MemoryStore, pero debemos instanciarlo.
        </p>
        <pre><code>
var sessionStore = new MemoryStore()          
        </code></pre>
        <p>ya que estamos en esta parte, vamos a declarar 2 variables mas que vamos a necesitar en el transcurso de nuestra autorizacion</p>
        <pre><code>
var parseCookie = require('express/node_modules/connect').utils.parseSignedCookies          
        </code></pre>
        <p>parseCookie es una funcion que parsea nuestras cookies que estan encriptadas, osea, le pasamos nuestra "frase secreta" y desencripta nuestra cookie</p>
        <pre><code>
var cookie = require('express/node_modules/cookie')          
        </code></pre>
        <p>cookie tiene funciones que vamos a utilizar con nuestras cookies</p>
        <h4>Autorizando!</h4>
        <p>para ello debemos leer las cookies que vienen en nuestros datos de handshake (los datos de handshake o "apreton de manos" se generan al establecerse la conexion del socket) el mismo tiene la siguiente estructura</p>
        <pre><code>
{
   headers: req.headers      
 , time: (new Date) +''       
 , address: socket.address()  
 , xdomain: !!headers.origin  
 , secure: socket.secure      
 , issued: +date              
 , url: request.url          
 , query: data.query          
}          
        </code></pre>
        <p>Entonces, como nuestra funcion recibe los datos de handshake con el nombre <code>handshakeData</code> las cookies se encuentran dentro de <code>handshakeData.headers.cookie</code></p>
        <p>Como nuestras cookies van codificadas al usuario, necesitamos decodificarlas, lo hacemos de la siguiente manera.</p>
        <pre><code>
if (handshakeData.headers.cookie){
  handshakeData.cookie = parseCookie(cookie.parse(handshakeData.headers.cookie),'M1Supp3RS3cr3TP@SsW0Rd');
};          
        </code></pre>
        <p>si existe la cookie, guarda dentro de nuestro handshake la cookie decodificada con parseCookie, dentro de parseCookie le pasamos nuestra cookie parseada como primer parametro (hecho con cookie.parse) y como segundo parametro nuestra frase secreta, la que le pasamos en la configuracion de node.js</p>
        <p>luego guardamos nuestro id de session en nuestro objeto <code>handshakeData</code> al que ahora gracias a parsearlo, podemos acceder de la siguiente manera:</p>
        <pre><code>
handshakeData.sessionID = handshakeData.cookie['express.sid'];          
        </code></pre>
        <p>ahora que tenemos el id, podemos buscar la sesion en nuestro sessionStore, lo hacemos con el metodo <code>get</code></p>
        <pre><code>
sessionStore.get(handshakeData.sessionID, function (err, session){});                  
        </code></pre>
        <p>Como ven, recive como primer parametro el id por el que voy a buscar, y como segundo una funcion callback, la misma recibe como primer parametro el error, y el segundo la sesion que obtuvo al hacer el <code>get</code> con el id</p>
        <p>dentro de esta funcion, si no pudo obtener la sesion completa la variable err, sino, me completa la variable session con la sesion del usuario, ahora vamos a corroborar que este logeado de la siguiente manera</p>
        <pre><code>
if (err){ callback('fallo la obtencion de sesion!',false) };
if (session){
  if (session.usuario){
    callback(null,true)
  } else {
    callback('el usuario no esta logeado', false)
  }
}          
        </code></pre>
        <p><code>callback</code> es una funcion que nos pasa socket.io para poder continuar con la autenticacion de nuestro socket, a ella la llamamos con el error primero, y el valor de lo que le estemos pasando despues, en el caso de que usuario exista dentro de sesion (lo que significa que esta logeado) llamamos a la funcion <code>callback(null,true)</code> osea, el error es null, y true por que autenticamos al usuario, caso contrario, le pasamos como error <b>'el usuario no esta logeado'</b> y false, ya que no permitimos que se conecte el socket</p>
        <p>el codigo final, queda de la siguiente manera</p>
        <pre><code>
io.configure(function (){
  io.set('authorization', function (handshakeData, callback) {
    if (handshakeData.headers.cookie)
    {
      handshakeData.cookie = parseCookie(cookie.parse(handshakeData.headers.cookie),'M1Supp3RS3cr3TP@SsW0Rd');
      handshakeData.sessionID = handshakeData.cookie['express.sid'];
      sessionStore.get(handshakeData.sessionID, function (err, session) {
        if (err){ callback('fallo la obtencion de sesion!',false) };
        if (session){
          if (session.usuario){
            callback(null,true)
          } else {
            callback('el usuario no esta logeado', false)
          }
        }
      })
    }
  });
});
        </code></pre>
        <p>Quedando el archivo <a href="https://github.com/theHazzard/nodejsAndSockets/blob/619c9098e7f4386401e033489009299fcc63a2a9/app.js">de la siguiente manera</a></p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/theHazzard">theHazzard</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>