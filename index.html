<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Curso NodeJs by theHazzard</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">   
      <header>
        <h1>Curso NodeJs</h1>
        <p>repositorio del curso empezado por @antoniopol</p>

        <p class="view"><a href="https://github.com/theHazzard/cursox">View the Project on GitHub <small>theHazzard/cursox</small></a></p>


        <ul>
          <li><a href="https://github.com/theHazzard/cursox/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/theHazzard/cursox/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/theHazzard/cursox">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
      <nav>
        <ul>
          <li><a href="#whatIsNode">Intro!</a></li>
          <li><a href="#SocketIo">Socket.IO</a></li>
          <li></li>
          <li></li>
          <li></li>
        </ul>
      </nav>
        <h3 id="whatIsNode">Node.js</h3>

        <p>
          Node.js te permite correr javascript del lado del servidor, es decir, utilizando el motor V8 de google permite correr javascript fuera del navegador, que es como comunmente era utilizado, node.js es un conjunto de librerias y funciones que corren sobre este motor de google
        </p>
        <h3 id="CallBack">Callback functions</h3>
        <p>
          lo que mas me a costado entender, es el manejo que tiene javascript de las funciones, javascript es un lenguaje funcional, y maneja las funciones como uno de sus objetos mas importantes, las funciones de callback, son enviadas como parametros a otras funciones, para ser llamadas desde dentro de las mismas
        </p>
        <p>
          voy a dar un ejemplo simple de callback para que se entienda bien su funcionamiento:
        </p>

        <pre>
          <code>
var suma = function(a,b,callback){
  var resutlado = a + b;
  callback(resultado);
};

suma(5,4,function(res){
  console.log(res);
});
          </code>
        </pre>
        <p>
          En el codigo anterior podemos ver que declaramos la funcion suma, la cual recibe 3 parametros, los 2 valores, y callback.
          Mas abajo vemos que llamamos a esta funcion para que realize la suma, y le pasamos una funcion declarada en la misma lista de parametros, la cual recibe un valor en "res" y lo imprime en consola.
          Entonces, que sucede? bien, dentro de suma realizamos la suma y le pasamos el resultado a callback, que es la funcion que le pasamos como parametro, la cual es llamada y imprime lindo y bonito el resultado.       
        </p>
        
        <h3>NPM</h3>
        <p>Node consta con un instalador de paquetes, el cual te permite installarlos de manera local en tu proyecto:</p>
        <pre><code>
npm install express
        </code></pre>
        <p>o de manera global:</p>
        <pre><code>
npm install -g express
        </code></pre>
        <p>de que me sirve una o la otra? bueno, algunos paquetes como el del ejemplo traen funciones que pueden ser llamadas al instalarlos de manera global, en el ejemplo, express puede ser llamado para crear una estructura basica de tu sitio, de esta manera</p>
        <pre><code>
express MiSitio -s -c stylus
        </code></pre>
        <p>en este ejemplo estamos creando un proyecto llamado MiSitio, este comando recibe parametros tambien, -s le dice que configure express para utilizar sesiones, y -c le dice que vamos a utilizar el motor stylus para el codigo css</p>
        <p>esto nos genera la configuracion basica para tener corriendo un proyecto en express, como el package.json, algunas vistas y tambien rutas</p>
        
        <h3 id="SocketIo">Socket.io</h3>
        <h4>Que es socket.io?</h4>
        <p>Socket.io es una libreria que apunta a crear aplicaciones realtime sin tener que preocuparte por el mecanismo de transporte de datos, o de el dispositivo final donde se corra tu aplicacion</p>
        <h4>Todo muy lindo pero... mecanismos de transporte?</h4>
        <p>El mecanismo de transporte es el metodo por el que se envian los datos, si tenes el ultimo chrome seguro tendras habilitado websockets, pero y si tu servidor no soporta websockets?, o en el caso que tengas un internet explorer 6, y un servidor que si soporte websockets, no podras utilizarlo?</p>
        <p>Aqui es donde entra socket.io, el verifica todo esto por su cuenta y decide cual es el mejor modo de transporte habilitado, si tenes un navegador que soporte websockets, usara websocket, sino, utilizara pooling, y dadas las circunstancias de que no este ninguno habilitado, insertara en tu pagina un swf (si, flash) y utilizara las funciones de flash para que todos puedan utilizar tu aplicacion!</p>
        <h4>Y esto en que me afecta a mi?</h4>
        <p>Pues facil, esto significa que tu aplicacion funcionara en cualquier dispositivo, con cualquier conexion y en cualquier circunstancia!</p>
        <h4>HeartBeats, timeouts etc.</h4>
        <p>una coneccion que no a recibido datos se cierra luego de haber pasado un tiempo, esto se conoce como timeout, entonces, que sucede si no e recibido datos en un buen tiempo a traves de un socket? facil! socket.io manda un heartbeat (literalmente significa latido de corazon) antes que termine el tiempo de timeout para informarle al servidor que seguimos vivos, gracias a esto la conexion sigue siempre activa, <b>esto lo hace solito socket.io</b> pero es bueno saberlo =)</p>
        
        <h3>Agregando sockets a nuestra aplicacion!</h3>
        <p>por fin la parte divertida! continuando la version que nos dejo nuestro amigo @antonioPol <a href="https://github.com/theHazzard/nodejsAndSockets/tree/v1.0" class="user-mention">v1.0</a> primero hay que instalar la libreria de sockets en nuestro proyecto, esto se puede realizar con el siguiente comando.</p>
        <pre><code>
npm install socket.io
        </code></pre>
        <p>ahora bien, una buena practica aqui, sobre todo si luego pensamos hacer un deployment a heroku o a nodejitsu es agregar el paquete al archivo packages.json, pero como yo soy perezoso, hay un comando para mi!</p>
        <pre><code>
npm install socket.io --save          
        </code></pre>
        <p>esto hace que se instale nuestro paquete o libreria, y ademas se agregue automaticamente al archivo packages.json, quedando de esta manera.</p>
        <pre><code>
"dependencies": {
  "express": "3.0.6",
  "jade": "0.28.1",
  "socket.io": "~0.9.13"
}          
        </code></pre>
        <p>ahora bien, desde aqui podemos continuar! para ello necesitamos, en el archivo app.js, agregar la libreria.</p>
        <pre><code>
var express = require('express')
  , routes = require('./routes')
  , user = require('./routes/user')
  , http = require('http')
  , path = require('path');          
        </code></pre>
        <p>ahora quedaria asi</p>
        <pre><code>
var express = require('express')
  , routes = require('./routes')
  , user = require('./routes/user')
  , app = express()
  , http = require('http').createServer(app)
  , io = require('socket.io')
  , io = io.listen(http)
  , path = require('path');
        </code></pre>
        <p>como podran ver se agrego la linea
        <br>
        <code>app = express()</code>
        <br>
        <p>esto estaba ya hecho mas abajo, pero es necesario hacerlo antes de declarar nuestra variable http, ya que ahora es necesario alimentar esta variable con nuestra instancia de express <br>ahora en la linea de abajo le agregamos el metodo createServer y le pasamos nuestra instancia de express. (en app)</p>
        <br>
        <p>ahora tenemos, debajo de <code>http</code> la variable <code>io</code></p>
        <code>io = require('socket.io')</code>
        <p>que hace esto? trae las funciones de la libreria a la variable <code>io!</code>, pues bien, ya tenemos en nuestra app las funciones de sockets.
        <br>pero esto no es todo!.
        <br>ahora hay que decirle a nuestra libreria que escuche por nuestro servidor http, como lo estamos haciendo en la linea de abajo</p>
        <code>io = io.listen(http)</code>
        <p>y listo, ahora en io, tenemos a nuestro socket escuchando en http</p>
        <p>solo nos queda decir que en el final, donde antes estaba escuchando nuestra instancia de http, hay que modificarlo de la siguiente manera</p>
        <pre><code>
http.listen(app.get('port'), function(){
  console.log("Express server listening on port " + app.get('port'));
});
        </code></pre>
        <p>esto se debe a que arriba ya estamos haciendo la parte de <code>.createServer</code><br><a href="https://github.com/theHazzard/nodejsAndSockets/tree/7ed0e0dff943890914de6c1369ea5e3d9000ea4d">Commit con los cambios explicados</a></p>
        
        <h3>Reciviendo los sockets conectados</h3>
        <h4>En el server...</h4>
        <pre><code>
io.sockets.on('connection',function (socket){
  socket.emit('mensaje','bienvenidos!')
})          
        </code></pre>
        <p>que estamos haciendo con esto? bueno, <code>io</code> es nuestra instancia de socket.io a la escucha de conexiones, ahora estamos agregando a los sockets un manejador del evento connection, osea, que cuando haya una conexion, ejecute la funcion que le estamos pasando, recuerdan lo de las <a href="#CallBack">funciones callback?</a>, bueno, aqui estamos haciendo uso de ellas, con esto le estamos diciendo "on connection do this", o "al haber una conexion hace esto" donde "esto" es la funcion</p>
        <p>la funcion callback que le estamos pasando recibe como parametro el socket que se conecto, este a diferencia de io.sockets(que son todos los sockets) es una conexion individual, osea un usuario unico, o una conexion unica a dicho usuario.</p>
        <p>luego donde hacemos <code>socket.emit('evento','mensaje')</code> le estamos diciendo que a este socket unico e individual le mandemos el evento mensaje, con el mensaje bienvenidos!</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/theHazzard">theHazzard</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>